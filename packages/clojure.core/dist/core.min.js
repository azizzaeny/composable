const{assign}=Object;var partial=(fn,...rightArgs)=>(...leftArgs)=>fn(...leftArgs,...rightArgs),apply=(...argv)=>{let[fn,...args]=argv;return (argv.length===1)?argn=>apply(fn,argn):fn(...args)},comp=(...fns)=>function(x){return fns.reduceRight(function(acc,fn){return fn(acc)},x)},constantly=x=>function(){return x},identity=x=>x,fnil=(f,x)=>function(){var args=[...arguments],numArgs=f.length;while (args.length<numArgs)args.push(x);return f.apply(null,args)},memoize=f=>{var cache=new Map();return (...args)=>{var key=JSON.stringify(args);if(!cache.has(key)){var result=f(...args);cache.set(key,result);return result}return cache.get(key)}},complement=f=>function(...args){return!f(...args)},complement=f=>(...args)=>!f(...args),juxt=(...fns)=>function(...args){return fns.map(fn=>fn(...args))},someFn=(...fns)=>function(x){for(let i=0;i<fns.length;i++)if(fns[i](x))return!0;return!1},partialRight=(fn,...leftArgs)=>(...rightArgs)=>fn(...leftArgs,...rightArgs),or=(...args)=>args.find(Boolean)||!1,and=(...tests)=>tests.every(Boolean),doseq=(seq,bodyFn)=>{for(const item of seq)bodyFn(item)},dof=(...exprs)=>{let result;for(const fn of exprs)result=fn();return result},isGt=(a,b)=>{if(!b)return b=>isGt(a,b);return a>b},isGte=(a,b)=>{if(!b)return b=>isGte(a,b);return a>=b},isLt=(a,b)=>{if(!b)return b=>isLt(a,b);return a<b},isLte=(a,b)=>{if(!b)return b=>isLt(a,b);return a<=b},isEqual=(...args)=>{let[a,b]=args;if(args.length===1)return b=>isEqual(a,b);if(isArray(a)&&isArray(b)){if(a.length!==b.length)return!1;for(let i=0;i<a.length;i++)if(!isEqual(a[i],b[i]))return!1;return!0}if(typeof a==='object'&&typeof b==='object'){let aKeys=Object.keys(a);let bKeys=Object.keys(b);if(aKeys.length!==bKeys.length)return!1;for(const key of aKeys)if(!isEqual(a[key],b[key]))return!1;return!0}return a===b},isZero=x=>x===0,isPos=x=>x>0,isNeg=x=>x<0,isInt=x=>Number.isInteger(x),isBoolean=x=>typeof x==='boolean',isTrue=x=>x===!0,isFalse=x=>x===!1,isInstance=(x,type)=>x instanceof type,isNil=x=>x===null,isSome=x=>x!==null,isFn=x=>typeof x==='function',isBlank=x=>isString(x)&&x.trim()==='',isNumber=value=>typeof value==='number'&&!Number.isNaN(value),isEven=x=>x%2===0,isOdd=x=>x%2!==0,isColl=value=>(value!==null&&typeof value==='object'),isArray=value=>isArray(value),isMap=value=>typeof value==='object'&&value!==null&&!isArray(value),isObject=isMap,isEmpty=coll=>{if(typeof coll==='object')return (Object.keys(coll).length===0);return coll.length===0},not=x=>!x,isContains=(...args)=>{let[coll,key]=args;if(args.length===1)return keyN=>isContains(coll,keyN);if(coll instanceof Map||coll instanceof Set)return coll.has(key);if(typeof coll==='object'){if(isArray(coll))return coll.includes(key);return Object.prototype.hasOwnProperty.call(coll,key)}else{if(isString(coll))return coll.includes(key);return!1}},isIncludes=(s,substr)=>{if(!substr)return substr=>isIncludes(s,substr);return s.includes(substr)},threadf=(val,...forms)=>forms.reduce((acc,form)=>{let[fn,...rest]=form;if(rest&&rest.length>0){return partial(fn,...rest)(acc)}return fn(acc)},val),threadl=(val,...forms)=>forms.reduce((acc,form)=>{let[fn,...rest]=form;if(rest&&rest.length>0){return partialRight(fn,...rest)(acc)}return fn(acc)},val),cond=(...clauses)=>clauses.reduce((acc,[condition,result])=>acc===void 0&&(condition===!0||!!condition)?result:acc,void 0),condp=(pred,expr,...clauses)=>{for(let i=0;i<clauses.length-1;i+=2){let result=clauses[i+1];if(pred(expr,clauses[i]))return result}let fallback=clauses[clauses.length-1];return isFn(fallback)?fallback(expr):fallback},condtf=(val,...clauses)=>clauses.reduce((acc,[condition,fn,...args])=>{if(condition)return fn(acc,...args);return acc},val),condtl=(val,...clauses)=>clauses.reduce((acc,[condition,fn,...args])=>{if(condition){return partialRight(fn,...args)(acc)}return acc},val),when=(test,...body)=>{test},whenNot=(test,...body)=>{!test},iff=(test,thenFn,elseFn=()=>{})=>test?thenFn():elseFn(),ifNot=(test,thenFn,elseFn=()=>{})=>{if(!test)return thenFn();return elseFn()},casef=(e,...clauses)=>{for(let i=0;i<clauses.length-1;i+=2)if(clauses[i]===e)return clauses[i+1];return clauses[clauses.length-1]},add=(...args)=>{let[a,b]=args;if(args.length===1)return b=>a+b;if(args.length===2)return a+b;return args.reduce((sum,num)=>sum+num,0)},subtract=(...args)=>{let[a,b]=args;if(args.length===1)return b=>a-b;if(args.length===2)return a-b;return args.reduce((sum,num)=>sum-num)},multiply=(...args)=>{let[a,b]=args;if(args.length===1)return b=>a*b;if(args.length===2)return a*b;return args.reduce((acc,n)=>acc*n)},divide=(...args)=>{let[a,b]=args;if(args.length===1)return b=>a/b;if(args.length===2)return a/b;return args.reduce((acc,n)=>acc/n)},quot=(...args)=>{let[a,b]=args;if(args.length===1)return b=>~~a/b;return ~~a/b},mod=(...args)=>{let[a,b]=args;if(args.length===1)return b=>a%b;return a%b},rem=(...args)=>{let[a,b]=args;if(args.length===1)return b=>((a%b)+b)%b;return ((a%b)+b)%b},inc=num=>num+1,dec=num=>num-1,max=(...args)=>{let[a,b]=args;if(args.length===1)return b=>Math.max(a,b);if(args.length===2)return Math.max(a,b);return args.reduce((acc,val)=>Math.max(acc,val))},min=(...args)=>{let[a,b]=args;if(args.length===1)return b=>Math.min(a,b);if(args.length===2)return Math.min(a,b);return args.reduce((acc,val)=>Math.min(acc,val))},toInt=num=>parseInt(`${num}`),subs=(...args)=>{let[str,start,end]=args;if(args.length===1)return (start,end)=>str.substring(start,end);return str.substring(start,end)},replace=(...args)=>{let[s,match,replacement]=args;if(args.length===1)return (match,replacement)=>s.replace(match,replacement);return s.replace(new RegExp(match, 'g'),replacement)},replaceFirst=(...args)=>{let[str,pattern,replacement]=args;if(args.length===1)return (pattern,replacement)=>str.replace(pattern,replacement);return str.replace(pattern,replacement)},join=(...args)=>{let[arr,separator]=args;if(args.length===1)return separator=>arr.join(separator);return arr.join(separator)},escape=str=>str.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),rePattern=pattern=>RegExp(pattern),reMatches=(...args)=>{let[str,pattern]=args;if(args.length===1)return pattern=>reMatches(str,pattern);var regex=new RegExp(pattern, 'g');var matches=[],match;while (match=regex.exec(str)!==null)matches.push(match[0]);return matches},capitalize=str=>str.charAt(0).toUpperCase()+str.slice(1),lowerCase=str=>str.toLowerCase(),upperCase=str=>str.toUpperCase(),trim=str=>str.trim(),trimNewline=str=>str.replace(/^[\n\r]+|[\n\r]+$/g,''),triml=str=>str.replace(/^\s+/,''),trimr=str=>str.replace(/\s+$/,''),char=n=>String.fromCharCode(n),keys=m=>Object.keys(m),vals=m=>Object.values(m),count=coll=>{if(isMap(coll))return keys(coll).length;return coll.length},conj=(...[coll,...xs])=>{if(!xs||xs.length===0)return (...xs)=>conj(coll,...xs);return[...coll,...xs]},cons=(...[x,...seq])=>{if(!seq||seq.length===0)return (...seq)=>cons(x,...seq);return [x].concat(...seq)},disj=(...[st,k,...ks])=>{if(!k)return (k,...ks)=>disj(st,k,...ks);return st.filter(item=>item!==k)},concat=(...[x,...zs])=>{if(!zs)return (...zs)=>concat(x,...zs);return x.concat(...zs)},first=seq=>seq[0],ffirst=seq=>first(seq[0]),second=([_,x])=>x,last=arr=>arr[arr.length-1],next=([_,...rest])=>rest,nfirst=x=>next(first(x)),nnext=x=>next(next(x)),fnext=x=>first(next(x)),take=(...[n,coll])=>{if(!coll)return coll=>take(n,coll);return coll.slice(0,n)},takeNth=(...[n,coll])=>{if(!coll)return coll=>takeNth(n,coll);return coll.filter((_,i)=>i%n===0)},takeNth=(...[n,coll])=>{if(!coll)return coll=>takeNth(n,coll);return coll.filter((_,i)=>i%n===0)},takeLast=(...[n,coll])=>{if(!coll)return coll=>takeLast(n,arr1=coll);return coll.slice(-n)},takeWhile=(...[pred,coll])=>{if(!coll)return coll=>takeWhile(pred,coll);let index=coll.findIndex(val=>!pred(val));return index===-1?coll:coll.slice(0,index)},nth=(...[coll,index])=>{if(!index)return index=>nth(coll,index);return coll[index]},rest=coll=>coll.slice(1),nthrest=(...[coll,n])=>{if(!n)return n=>nthrest(coll,n);return coll.filter((_,i)=>i>=n)},drop=(...[n,coll])=>{if(!coll)return coll=>drop(n,coll);return coll.slice(n)},dropLast=coll=>coll.slice(0,-1),dropWhile=(pred,coll)=>{let index=0;while (index<coll.length&&pred(coll[index]))index++;return coll.slice(index)},peek=coll=>coll[coll.length-1],pop=([f,...coll])=>coll,get=(...[map,key])=>{if(!key)return key=>map[key];return map[key]},getIn=(...[m,ks,notFound=void 0])=>{if(!ks)return ks=>getIn(m,ks);return ks.reduce((acc,key)=>{if(acc&&typeof acc==='object'&&key in acc)return acc[key];return notFound},m)},assoc=(...[m,key,val])=>{if(!key&&!val)return (key,val)=>assoc(m,key,val);if(!val)return val=>assoc(m,key,val);if(isMap(m))return{...m,[key]:val};if(isColl(m)){let coll=[...m];return coll[key]=val,coll}},assocIn=(...[m,ks,v])=>{if(!ks||!v)return (ks,v)=>assocIn(m,ks,v);if(!v)return v=>assocIn(m,ks,v);let[fk,...rk]=isArray(ks)?ks:[ks];return assoc(m,fk,rk.length===0?v:assocIn(m[fk]||{},rk,v))},dissoc=(...[m,...keys])=>{if(!keys||!1)return (...keys)=>dissoc(m,...keys);let coll=isMap(m)?{...m}:[...m];return keys.map(key=>delete coll[key]),(isMap(m)?coll:coll.filter(f=>f!==null))},update=(...[m,k,fn])=>{if(!k||!fn)return (k,fn)=>update(m,k,fn);if(!fn)return fn=>update(m,k,fn);if(isArray(m)){let coll=[...m];return coll[k]=fn(coll[k]),coll}return{...m,[k]:fn(m[k])}},updateIn=(...[m,ks,fn])=>{if(!ks||!fn)return (ks,fn)=>updateIn(m,ks,fn);if(!fn)return fn=>updateIn(m,ks,fn);let[k,...rk]=ks;return (rk.length===0)?update(m,k,fn):update(m,k,v=>updateIn(v,rk,fn))},merge=(...[m,...rest])=>{if(!rest||rest.length===0)return (...rest)=>merge(m,...rest);return assign({},m,...rest)},mergeWith=(...[fn,...maps])=>{if(!maps||maps.length===0)return (...maps)=>mergeWith(fn,...maps);let[m,...coll]=maps;return Object.entries(assign({},m,...coll)).reduce((acc,[k,v])=>(acc[k]=fn(v),acc),{})},selectKeys=(...[m,ks])=>{if(!ks)return ks=>selectKeys(m,ks);return Object.fromEntries(Object.entries(m).filter(([key,value])=>ks.includes(key)))},renameKeys=(...[m,ksmap])=>{if(!ksmap)return ksmap=>renameKeys(m,ksmap);return Object.entries(m).reduce((acc,[key,value])=>ksmap[key]?{...acc,[ksmap[key]]:value}:{...acc,[key]:value},{})},zipmap=(...[ks,vals])=>{if(!vals)return ks=>zipmap(ks,vals);return ks.reduce((acc,key,i)=>(acc[key]=vals[i],acc),{})},into=(...[to,from])=>{if(!from)return from=>into(to,from);if(isMap(to))return from.reduce((acc,[key,value])=>({...acc,[key]:value}),{});return Object.entries(from).map(([key,value])=>[key,value])},seq=coll=>{if(isArray(coll))return coll;if(typeof coll==='object')return Object.entries(coll);if(isString(coll))return[...coll];return coll},vec=coll=>{if(!coll)return[];if(isArray(coll))return coll;if(isString(coll))return coll.split('');if(isFn(coll[Symbol.iterator]))return[...coll];return Object.values(coll)},subvec=(...[v,start,end])=>{!end&&(end=v.length);if(start<0||end<0)return null;return v.slice(start,end)},repeat=(...[n,x])=>{if(!x)return x=>repeat(n,x);return Array(n).fill(x)},repeatedly=(...args)=>{let n,fn;args.length===1&&(fn=args[0]);args.length===2&&(n=args[0],fn=args[1]);if(n===void 0)return function*(){while (!0)yield fn()};return Array.from({length:n},()=>fn())},range=(...args)=>{let[start,end,step=1]=args;args.length===1&&(end=start,start=0);let result=[];for(let i=start;i<end;i+=step)result.push(i);return result},keep=(...[f,coll])=>{if(!coll)return coll=>keep(f,coll);return coll.reduce((acc,curr)=>{let res=f(curr);if(res!==null&&res!==void 0)return acc.concat(res);return acc},[])},keepIndexed=(...[f,coll])=>{if(!coll)return coll=>keep(f,coll);return coll.reduce((acc,curr,i)=>{let res=f(i,curr);if(res!==null&&res!==void 0)return acc.concat(res);return acc},[])},split=(...[p,ch])=>{if(!ch)return ch=>split(p,ch);return p.split(ch)},splitAt=(...[n,coll])=>{if(!coll)return coll=>splitAt(n,coll);return[coll.slice(0,n),coll.slice(n)]},splitWith=(pred,coll)=>{let index=coll.findIndex(element=>!pred(element));if(index===-1)return[coll,[]];return[coll.slice(0,index),coll.slice(index)]},splitLines=str=>str.split('\n'),shuffle=coll=>{let result=coll.slice();for(let i=result.length-1;i>0;i--){const j=~~Math.random()*(i+1);[result[i],result[j]]=[result[j],result[i]]}return result},randNth=coll=>{let i=~~Math.random()*coll.length;return coll[i]},rand=()=>Math.random(),randInt=(max=100)=>~~Math.random()*max,find=(...[map,key])=>{if(!key)return key=>find(map,key);return Object.entries(map).find(([k,v])=>k===key)},map=(...[f,coll])=>(!coll)?coll=>map(f,coll):coll.map(f),mapcat=(...[f,...coll])=>{if(!coll||coll.length===0)return (...coll)=>mapcat(f,...coll);return coll.flat().map(f).reduce((acc,val)=>acc.concat(val),[])},mapIndexed=(...[f,coll])=>(!coll)?coll=>map(f,coll):coll.map((val,idx)=>f(val,idx)),filter=(...[pred,coll])=>(!coll)?coll=>filter(pred,coll):coll.filter(pred),remove=(...[pred,coll])=>{if(!coll)return coll=>remove(pred,coll);return coll.filter(item=>!pred(item))},isEvery=(...[pred,coll])=>{if(!coll)return coll=>isEvery(pred,coll);return coll.every(pred,coll)},everyPred=(...fns)=>function(x){for(let i=0;i<fns.length;i++)if(!fns[i](x))return!1;return!0},flatten=x=>x.flat(),reduce=(...args)=>{let[f,val,coll]=args;if(args.length===1)return coll=>reduce(f,void 0,coll);if(args.length===2)return coll=>reduce(f,val,coll);return coll.reduce(f,val)},sort=(...args)=>{let[arr,comp=(a,b)=>a-b]=args;return args.length===1?[...arr].sort():[...arr].sort(comp)},sortBy=(...args)=>{let[fn,coll]=args;if(args.length===1)return coll=>[...coll].sort((a,b)=>fn(a)-fn(b));return [...coll].sort((a,b)=>fn(a)-fn(b))},compare=(a,b)=>{if(a<b)return -1;if(a>b)return 1;return 0},reverse=coll=>[...coll].reverse(),interleave=(...args)=>{let[c1,c2,...colls]=args;if(args.length===2)return c1.map((v,i)=>[v,c2[i]]).flat()},interpose=(...args)=>{let[sep,coll]=args;if(args.length===1)return coll=>coll.flatMap((val,i)=>i===coll.length-1?val:[val,sep]);return coll.flatMap((val,i)=>i===coll.length-1?val:[val,sep])},distinct=coll=>[...new Set(coll)],groupBy=(...[f,coll])=>{if(!coll)return coll=>groupBy(f,coll);return coll.reduce((acc,curr)=>{let key=f(curr);!acc[key]&&(acc[key]=[]);return acc[key].push(curr),acc},{})},frequencies=coll=>{let freqMap=new Map();for(const el of coll)freqMap.set(el,(freqMap.get(el)||0)+1);return Object.fromEntries(freqMap)},partition=(...args)=>{let[n,coll]=args;if(args.length===1)return coll=>partition(n,coll);let result=[];for(let i=0;i<coll.length;i+=n)result.push(coll.slice(i,i+n));return result},partitionBy=(...args)=>{let[fn,coll]=args;if(args.length===1)return coll=>partitionBy(fn,coll);var result=[];let group=[];let prevValue;for(const elem of coll){var value=fn(elem);value===prevValue||prevValue===void 0?group.push(elem):result.push(group);prevValue=value}group.length>0&&result.push(group);return result},partitionAll=(...args)=>{let[size,arr]=args;if(args.length===1)return coll=>partitionAll(size,coll);if(!arr||!arr.length)return[];var result=[];for(let i=0;i<arr.length;i+=size)result.push(arr.slice(i,i+size));return result},union=(...args)=>{let[s1,s2,...sets]=args;return (args.length==1)?(s2,...sets)=>union(s1,s2,...sets):[...new Set([...s1,...s2,...sets])]},difference=(...args)=>{let[s1,s2,...sets]=args;if(args.length===1)return (s2,...sets)=>difference(s1,s2,...sets);return s1.filter(x=>!s2.includes(x))},intersection=(...args)=>{let[s1,s2,...sets]=args;if(args.length===1)return (s2,...sets)=>intersection(s1,s2,...sets);return s1.filter(x=>s2.includes(x))},atom=state=>{let watchers={};let validator=null;var deref=(()=>state),reset=(newValue=>{let validatedValue=validate(newValue);state=validatedValue;notifyWatchers(state,state);return (state===validatedValue)}),swap=(updateFn=>{let validatedValue=validate(updateFn(state));state=validatedValue;notifyWatchers(state,state);return (state===validatedValue)}),addWatch=((name,watcherFn)=>(watchers[name]=watcherFn,!0)),removeWatch=(name=>delete watchers[name]),notifyWatchers=(oldState,newState)=>{for(const watcherName of Object.keys(watchers))watchers[watcherName](oldState,newState)},compareAndSet=((expectedValue,newValue)=>{if(state===expectedValue){let validatedValue=validate(newValue);state=validatedValue;notifyWatchers(expectedValue,state);return state===validatedValue}return!1}),setValidator=(validatorFn=>validator=validatorFn),removeValidator=(()=>validator=null),validate=newValue=>{let defaultValidation=validator?validator(newValue):!0;return defaultValidation?newValue:state};return{deref,reset,swap,addWatch,removeWatch,compareAndSet,setValidator,removeValidator}},deref=atom=>{if(!atom.deref)return null;return atom.deref()},reset=(...args)=>{let[atom,value]=args;if(args.length===1)return value=>atom.reset(value);return atom.reset(value),atom.deref()},swap=(...args)=>{let[atom,fn,...rest]=args;if(args.length===1)return (fn,...rest)=>atom.swap(fn,...rest);return atom.swap(fn,...args),atom.deref()},compareAndSet=(...args)=>{let[atom,expected,newVal]=args;if(args.length===1)return (expected,newVal)=>atom.compareAndSet(expected,newVal);return atom.compareAndSet(expected,newVal)},addWatch=(...args)=>{let[atom,name,watcherFn]=args;if(args.length===1)return (name,watcherFn)=>atom.addWatch(name,watcherFn);return atom.addWatch(name,watcherFn)},removeWatch=(...args)=>{let[atom,watcherFn]=args;if(args.length===1)return watcherFn=>atom.removeWatch(watcherFn);return atom.removeWatch(watcherFn)},setValidator=(...args)=>{let[atom,validatorFn]=args;if(args.length===1)return validatorFn=>atom.setValidator(validatorFn);return atom.setValidator(validatorFn)},isString=a=>typeof a==='string';