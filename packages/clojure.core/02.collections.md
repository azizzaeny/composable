### @zaeny/clojure.core/collections

#### count
`(count coll)`
```js path=dist/core.js
var count = (coll) => coll.length;
```
usage: 
```js path=dist/test.core.js
test('count coll', ()=>{
  assert.equal(count([1,2]),2)
})
```
#### conj
`(conj)(conj coll)(conj coll x)(conj coll x & xs)`

```js path=dist/core.js
var conj = (...args) =>{
  let [coll, ...items] = args;
  return (args.length === 1)
    ? (itemA) => conj(coll, itemA)
    : [...coll, ...items]
}
```
usage: 
```js path=dist/test.core.js
test('test conj single', ()=>{
  assert.deepEqual(conj(['a'], 'a'),['a','a'])
});

test('test conj array', ()=>{
  assert.deepEqual(conj(['a', 'b'], ['c']),['a', 'b', ['c']])
})

test('test multiple conj', ()=>{
  assert.deepEqual(conj(['a'], 'b', 'c'),['a', 'b', 'c'])
});

```
#### cons
`(cons x seq)`
```js path=dist/core.js
var cons = (...args) =>{
  let [item, ...seq] = args;
  return (args.length === 1)
    ? (seqA) => cons(item, seqA)
    : [item].concat(...seq)
}
```
usage: 
```js path=dist/test.core.js
test('cons array', ()=>{
  assert.deepEqual(
    cons(0,[1,2,3]),
    [0,1,2,3]
  )
})
```

#### first
`(first coll)`
```js path=dist/core.js
var first = (seq) => seq[0];
```
usage: 
```js path=dist/test.core.js
test('test first array', ()=>{
  assert.equal(first([1,2]),1)
})
```


#### ffirst
`(ffirst coll)`
```js path=dist/core.js
var ffirst = (seq) => first(seq[0])
```
usage: 
```js path=dist/test.core.js
test('first of first of arrays', ()=>{
  assert.deepEqual(ffirst([[0, 1], [1,2]]),0)
});
```

#### nth
`(nth coll index)(nth coll index not-found)`
```js path=dist/core.js
var nth = (...args) => {
  let [seq, n] = args;
  if(args.length === 1) return (nn) => nth(seq, nn);
  return seq[n];
}

```
usage: 
```js path=dist/test.core.js
test('nth index of collections', ()=>{
  assert.equal(nth([1,2,3,4], 2), 3)  
})

```

#### seq 
`(seq coll)` sequence in this is converting objects & strings

```js path=dist/core.js
var seq = (arg) =>{
  if(Array.isArray(arg)){
    return arg;
  }
  if(typeof arg === "object"){
    return Object.entries(arg);
  }
  if(typeof arg === "string"){
    return Array.from(arg);
  }
  return arg;
}
```
usage:
```js path=dist/test.core.js
test('should test the conversion of object', ()=>{
  assert.deepEqual(seq({a:1, b:2}), [["a", 1], ["b", 2]]);
});
test('should convert string into sequences', ()=>{
  assert.deepEqual(seq('aziz'), ['a', 'z','i', 'z'])
})
```

#### peek
`(peek coll)`
```js path=dist/core.js
var peek = (stack) => stack[stack.length - 1];
```
usage: 
```js path=dist/test.core.js
assert.equal(peek([1,2,3,4]), 4); // 4
```

#### rest
`(rest coll)`
```js path=dist/core.js
var rest = (seq) => seq.slice(1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(rest([1,2,3]), [2,3])
```

#### pop
`(pop coll)`
```js path=dist/core.js
var pop = (stack) => stack.slice(0, -1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(pop([1,2,3]), [1,2])
```

#### disj
`(disj set)(disj set key)(disj set key & ks)`

```js path=dist/core.js
var disj = (...args) =>{
  let [coll, key, ...rest] = args;
  if (args.length === 2) {
    return coll.filter((item) => item !== key);
  } else if (args.length === 1) {
    return (key) => disj(coll, key);
  }
}
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(disj([1,2, 3],1), [2,3])
```

#### takeNth
(take-nth n)(take-nth n coll)
```js path=dist/core.js
var takeNth = (...args) => {
  let [n, arr] = args;
  if (args.length === 1) {
    return coll => takeNth(n, coll)
  }
  return arr.filter((_, i) => i % n === 0);
}
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(takeNth(2,[1,2,3,4,5,6,7,8]), [1,3,5,7])
assert.deepEqual(takeNth(3, [1,2,3,4,5,6,7,8]),[1,4,7])
```
#### take
(take n)(take n coll)
```js path=dist/core.js
var take = (...args) =>{
  let [n, arr] = args;
  if (args.length === 1) {
    return coll => take(n, coll);
  }
  return arr.slice(0, n);
}
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(take(2, [1,2,3,4,5,6,7,8]), [1,2])
```
#### second
(second x)
```js path=dist/core.js
var second = ([_, x]) => x;
```
usage: 
```js path=dist/test.core.js
assert.deppEqual(second([1,2]), 2)
```

#### last
(last coll)
```js path=dist/core.js
var last = (arr) => arr[arr.length - 1];
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(last([1,2,3,4,5]), 5);
```

#### next
(next coll)
```js path=dist/core.js
var next = ([_, ...rest]) => { return rest; }
```
usage: 
```js path=dist/test.core.js
deepEqual(next([1,2,3,4]), [2,3,4]);
```

#### nfirst
(nfirst x)
```js path=dist/core.js
var nfirst = (arr) =>  next(first(arr));

```
usage: 
```js path=dist/test.core.js
deepEqual(nfirst([[1,2,3], [4,6,7]]), [2,3])
```

#### nnext
(nnext x)
```js path=dist/core.js
var nnext = (arr) => next(next(arr));
```
usage: 
```js path=dist/test.core.js
deepEqual(nnext([1,2,3,4]), [3,4])
```
#### fnext
(fnext x)
```js path=dist/core.js
var fnext = (arr) => first(next(arr));
```
usage: 
```js path=dist/test.core.js
deepEqual(fnext([[1,2,3], [4,5,6]]), [4,5,6]);
```

#### takeLast
(take-last n coll)
```js path=dist/core.js
var takeLast= (...args)=>{
  let [n, arr] = args
  if(args.length === 1) return (arr1) => takeLast(n, arr1);
  return arr.slice(-n);  
}
```
usage: 
```js path=dist/test.core.js
deepEqual(takeLast(2, [1,2,3,4,5,6,7]), [6,7])
deepEqual(takeLast(3)([1,2,3,4,5,6]), [4,5,6])
```

#### takeWhile
(take-while pred)(take-while pred coll)
```js path=dist/core.js
var takeWhile = (...args) =>{
  let [predicate, arr] = args;
  if (args.length === 1) {
    return coll => takeWhile(predicate, coll)
  }
  const index = arr.findIndex(val => !predicate(val))
  return index === -1 ? arr : arr.slice(0, index)
}
```
usage: 
```js path=dist/test.core.js
deepEqual(takeWhile((n)=> n < 5, [1,2,3,4,5,6,7,8]), [1,2,3,4])
```

#### nthrest
(nthrest coll n)
```js path=dist/core.js
var nthrest = (...args) =>{
  let [n, arr] = args;
  if (args.length === 1) {
    return coll => nthrest(n, coll)
  }
  return arr.filter((_, i) => i >= n)
}
```
usage: 
```js path=dist/test.core.js
deepEqual(nthrest(2, [1,2,3,4,5,6]), [3,4,5,6])
```


#### drop
(drop n)(drop n coll)
```js path=dist/core.js
var drop = (...args) => {
  let [n, arr] = args;
  if(args.length === 1) {
    return (arr1) => drop(n, arr1);
  }
  return arr.slice(n);
}
```
usage: 
```js path=dist/test.core.js
deepEqual(drop(2, [1,2,3,4,5]), [3,4,5])
```


#### dropLast
(drop-last coll)(drop-last n coll)
```js path=dist/core.js
var dropLast = (arr) => { return arr.slice(0, -1); }
```
usage: 
```js path=dist/test.core.js
deepEqual(dropLast([1,2,3,4]), [1,2,3]);
```
#### dropWhile (TODO)

#### splitAt
(split-with pred coll)
```js path=dist/core.js

var splitAt = (...args) =>{
  let [n, coll] = args;
  return (args.length === 1)
    ? (colln) => splitAt(n, colln)
    : [coll.slice(0, n), coll.slice(n)]
}

```
usage: 
```js path=dist/test.core.js
splitAt(2, [1,2,3,4,5,6]) //[ [ 1, 2 ], [ 3, 4, 5, 6 ] ]
```
#### splitWith (TODO)
(split-with pred coll)

#### shuffle
(shuffle coll)
```js path=dist/core.js
var shuffle = (coll) => {
  const result = coll.slice();
  for (let i = result.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [result[i], result[j]] = [result[j], result[i]];
  }
  return result;
};

```
usage: 
```js path=dist/test.core.js
shuffle([1,2,3,4,5,6,7,7,8]);
```


#### randNth
(rand-nth coll)
```js path=dist/core.js
var randNth = (coll) => {
  const i = Math.floor(Math.random() * coll.length);
  return coll[i];
};

```
usage: 
```js path=dist/test.core.js
randNth([1,2,3,4,5,6,7])
```

#### vec
(vec coll)
```js path=dist/core.js
var vec = (coll) =>{
  if (!coll) {
    return [];
  }
  if (Array.isArray(coll)) {
    return coll;
  }
  if (typeof coll === 'string') {
    return coll.split('');
  }
  if (typeof coll[Symbol.iterator] === 'function') {
    return Array.from(coll);
  }
  return Object.values(coll);
}
```
usage: 
```js path=dist/test.core.js
vec({a: 'b'})
vec('asdff')
vec([1,2,3,4,5])
```

#### subvec
(subvec v start)(subvec v start end)
```js path=dist/core.js

var subvec = (coll, start, end)=>{
  if (!end) {
    end = coll.length;
  }
  if (start < 0 || end < 0) {
    throw new Error('start and end must be non-negative');
  }
  return coll.slice(start, end);
}

```
usage: 
```js path=dist/test.core.js
subvec([1,2,3])
```


#### repeat
(repeat x)(repeat n x)

#### range
(range)(range end)(range start end)(range start end step)

#### keep
(keep f)(keep f coll)

#### keepIndexed
(keep-indexed f)(keep-indexed f coll)

#### find
(find map key)

#### map
(map f)(map f coll)(map f c1 c2)(map f c1 c2 c3)(map f c1 c2 c3 & colls)

#### filter
(filter pred)(filter pred coll)

#### remove
(remove pred)(remove pred coll)

#### reduce
(reduce f coll)(reduce f val coll)

#### concat
(concat)(concat x)(concat x y)(concat x y & zs)

#### mapcat
(mapcat f)(mapcat f & colls)

#### mapIndexed
(map-indexed f)(map-indexed f coll)

#### flatten
(flatten x)

#### distinct
(distinct)(distinct coll)

#### interleave
(interleave)(interleave c1)(interleave c1 c2)(interleave c1 c2 & colls)

#### interpose
(interpose sep)(interpose sep coll)

#### reverse
(reverse coll)

#### sort
(sort coll)(sort comp coll)

#### sortBy
(sort-by keyfn coll)(sort-by keyfn comp coll)

#### compare
(compare x y)

#### groupBy
(group-by f coll)

#### partition
(partition n coll)(partition n step coll)(partition n step pad coll)

#### partitionAll
(partition-all n)(partition-all n coll)(partition-all n step coll)

#### partitionBy
(partition-by f)(partition-by f coll)

#### frequencies
(frequencies coll)

#### union
(union)(union s1)(union s1 s2)(union s1 s2 & sets)

#### difference
(difference s1)(difference s1 s2)(difference s1 s2 & sets)

#### intersection
`(intersection s1)(intersection s1 s2)(intersection s1 s2 & sets)`
```js path=dist/core.js
var intersection = (...args) =>{
  let [arr1, arr2] = args;
  if(args.length === 1) return (arr) => intersection(arr1, arr);
  return arr1.filter((x) => arr2.includes(x));
}
```
usage: 
```js path=dist/test.core.js
assert.equal(intersection([1,2], [2,3]), 2)
```


#### every

#### whenFirst
(when-first bindings & body)
