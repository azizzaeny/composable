### @zaeny/clojure.core/collections

#### count
`(count coll)`
```js path=dist/core.js
var count = (coll) => coll.length;
```
usage: 
```js path=dist/test.core.js
test('count coll', ()=>{
  assert.equal(count([1,2]),2)
})
```
#### conj
`(conj)(conj coll)(conj coll x)(conj coll x & xs)`

```js path=dist/core.js
var conj = (...args) =>{
  let [coll, ...items] = args;
  return (args.length === 1)
    ? (itemA) => conj(coll, itemA)
    : [...coll, ...items]
}
```
usage: 
```js path=dist/test.core.js
test('test conj single', ()=>{
  assert.deepEqual(conj(['a'], 'a'),['a','a'])
});

test('test conj array', ()=>{
  assert.deepEqual(conj(['a', 'b'], ['c']),['a', 'b', ['c']])
})

test('test multiple conj', ()=>{
  assert.deepEqual(conj(['a'], 'b', 'c'),['a', 'b', 'c'])
});

```
#### cons
`(cons x seq)`
```js path=dist/core.js
var cons = (...args) =>{
  let [item, ...seq] = args;
  return (args.length === 1)
    ? (seqA) => cons(item, seqA)
    : [item].concat(...seq)
}
```
usage: 
```js path=dist/test.core.js
test('cons array', ()=>{
  assert.deepEqual(
    cons(0,[1,2,3]),
    [0,1,2,3]
  )
})
```

#### first
`(first coll)`
```js path=dist/core.js
var first = (seq) => seq[0];
```
usage: 
```js path=dist/test.core.js
test('test first array', ()=>{
  assert.equal(first([1,2]),1)
})
```


#### ffirst
`(ffirst coll)`
```js path=dist/core.js
var ffirst = (seq) => first(seq[0])
```
usage: 
```js path=dist/test.core.js
test('first of first of arrays', ()=>{
  assert.deepEqual(ffirst([[0, 1], [1,2]]),0)
});
```

#### nth
`(nth coll index)(nth coll index not-found)`
```js path=dist/core.js
var nth = (...args) => {
  let [seq, n] = args;
  if(args.length === 1) return (nn) => nth(seq, nn);
  return seq[n];
}

```
usage: 
```js path=dist/test.core.js
test('nth index of collections', ()=>{
  assert.equal(nth([1,2,3,4], 2), 3)  
})

```

#### seq 
`(seq coll)` sequence in this is converting objects & strings

```js path=dist/core.js
var seq = (arg) =>{
  if(Array.isArray(arg)){
    return arg;
  }
  if(typeof arg === "object"){
    return Object.entries(arg);
  }
  if(typeof arg === "string"){
    return Array.from(arg);
  }
  return arg;
}
```
usage:
```js path=dist/test.core.js
test('should test the conversion of object', ()=>{
  assert.deepEqual(seq({a:1, b:2}), [["a", 1], ["b", 2]]);
});
test('should convert string into sequences', ()=>{
  assert.deepEqual(seq('aziz'), ['a', 'z','i', 'z'])
})
```

#### peek
`(peek coll)`
```js path=dist/core.js
var peek = (stack) => stack[stack.length - 1];
```
usage: 
```js path=dist/test.core.js
assert.equal(peek([1,2,3,4]), 4); // 4
```

#### rest
`(rest coll)`
```js path=dist/core.js
var rest = (seq) => seq.slice(1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(rest([1,2,3]), [2,3])
```

#### pop
`(pop coll)`
```js path=dist/core.js
var pop = (stack) => stack.slice(0, -1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(pop([1,2,3]), [1,2])
```

#### disj
`(disj set)(disj set key)(disj set key & ks)`

```js path=dist/core.js
var disj = (...args) =>{
  let [coll, key, ...rest] = args;
  if (args.length === 2) {
    return coll.filter((item) => item !== key);
  } else if (args.length === 1) {
    return (key) => disj(coll, key);
  }
}
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(disj([1,2, 3],1), [2,3])
```
