### @zaeny/clojure.core/collections

#### count
`(count coll)`
```js path=dist/core.js
var count = (coll) => coll.length;
```
usage: 
```js path=dist/test.core.js
test('count coll', ()=>{
  assert.equal(count([1,2]),2)
})
```
#### conj
`(conj)(conj coll)(conj coll x)(conj coll x & xs)`

```js path=dist/core.js
var conj = (...args) =>{
  let [coll, ...items] = args;
  return (args.length === 1)
    ? (itemA) => conj(coll, itemA)
    : [...coll, ...items]
}
```
usage: 
```js path=dist/test.core.js
test('test conj single', ()=>{
  assert.deepEqual(conj(['a'], 'a'),['a','a'])
});

test('test conj array', ()=>{
  assert.deepEqual(conj(['a', 'b'], ['c']),['a', 'b', ['c']])
})

test('test multiple conj', ()=>{
  assert.deepEqual(conj(['a'], 'b', 'c'),['a', 'b', 'c'])
});

```
#### cons
`(cons x seq)`
```js path=dist/core.js
var cons = (...args) =>{
  let [item, ...seq] = args;
  return (args.length === 1)
    ? (seqA) => cons(item, seqA)
    : [item].concat(...seq)
}
```
usage: 
```js path=dist/test.core.js
test('cons array', ()=>{
  assert.deepEqual(
    cons(0,[1,2,3]),
    [0,1,2,3]
  )
})
```

#### first
`(first coll)`
```js path=dist/core.js
var first = (seq) => seq[0];
```
usage: 
```js path=dist/test.core.js
test('test first array', ()=>{
  assert.equal(first([1,2]),1)
})
```


#### ffirst
`(ffirst coll)`
```js path=dist/core.js
var ffirst = (seq) => first(seq[0])
```
usage: 
```js path=dist/test.core.js
test('first of first of arrays', ()=>{
  assert.deepEqual(ffirst([[0, 1], [1,2]]),0)
});
```

#### nth
`(nth coll index)(nth coll index not-found)`
```js path=dist/core.js
var nth = (...args) => {
  let [seq, n] = args;
  if(args.length === 1) return (nn) => nth(seq, nn);
  return seq[n];
}

```
usage: 
```js path=dist/test.core.js
test('nth index of collections', ()=>{
  assert.equal(nth([1,2,3,4], 2), 3)  
})

```

#### seq 
`(seq coll)` sequence in this is converting objects & strings

```js path=dist/core.js
var seq = (arg) =>{
  if(Array.isArray(arg)){
    return arg;
  }
  if(typeof arg === "object"){
    return Object.entries(arg);
  }
  if(typeof arg === "string"){
    return Array.from(arg);
  }
  return arg;
}
```
usage:
```js path=dist/test.core.js
test('should test the conversion of object', ()=>{
  assert.deepEqual(seq({a:1, b:2}), [["a", 1], ["b", 2]]);
});
test('should convert string into sequences', ()=>{
  assert.deepEqual(seq('aziz'), ['a', 'z','i', 'z'])
})
```

#### peek
`(peek coll)`
```js path=dist/core.js
var peek = (stack) => stack[stack.length - 1];
```
usage: 
```js path=dist/test.core.js
assert.equal(peek([1,2,3,4]), 4); // 4
```

#### rest
`(rest coll)`
```js path=dist/core.js
var rest = (seq) => seq.slice(1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(rest([1,2,3]), [2,3])
```

#### pop
`(pop coll)`
```js path=dist/core.js
var pop = (stack) => stack.slice(0, -1);
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(pop([1,2,3]), [1,2])
```

#### disj
`(disj set)(disj set key)(disj set key & ks)`

```js path=dist/core.js
var disj = (...args) =>{
  let [coll, key, ...rest] = args;
  if (args.length === 2) {
    return coll.filter((item) => item !== key);
  } else if (args.length === 1) {
    return (key) => disj(coll, key);
  }
}
```
usage: 
```js path=dist/test.core.js
assert.deepEqual(disj([1,2, 3],1), [2,3])
```

#### takeNth
(take-nth n)(take-nth n coll)

#### take
(take n)(take n coll)

#### second
(second x)

#### last
(last coll)

#### next
(next coll)

#### nfirst
(nnext x)

#### nnext
(nnext x)

#### fnext
(fnext x)

#### takeLast
(take-last n coll)

#### takeWhile
(take-while pred)(take-while pred coll)

#### nthrest
(nthrest coll n)

#### drop
(drop n)(drop n coll)

#### dropLast
(drop-last coll)(drop-last n coll)

#### dropWhile (TODO)

#### splitAt
(split-with pred coll)

#### splitWith
(split-with pred coll)

#### shuffle
(shuffle coll)

#### randNth
(rand-nth coll)

#### vec
(vec coll)

#### subvec
(subvec v start)(subvec v start end)

#### repeat
(repeat x)(repeat n x)

#### range
(range)(range end)(range start end)(range start end step)

#### keep
(keep f)(keep f coll)

#### keepIndexed
(keep-indexed f)(keep-indexed f coll)

#### find
(find map key)

#### map
(map f)(map f coll)(map f c1 c2)(map f c1 c2 c3)(map f c1 c2 c3 & colls)

#### filter
(filter pred)(filter pred coll)

#### remove
(remove pred)(remove pred coll)

#### reduce
(reduce f coll)(reduce f val coll)

#### concat
(concat)(concat x)(concat x y)(concat x y & zs)

#### mapcat
(mapcat f)(mapcat f & colls)

#### mapIndexed
(map-indexed f)(map-indexed f coll)

#### flatten
(flatten x)

#### distinct
(distinct)(distinct coll)

#### interleave
(interleave)(interleave c1)(interleave c1 c2)(interleave c1 c2 & colls)

#### interpose
(interpose sep)(interpose sep coll)

#### reverse
(reverse coll)

#### sort
(sort coll)(sort comp coll)

#### sortBy
(sort-by keyfn coll)(sort-by keyfn comp coll)

#### compare
(compare x y)

#### groupBy
(group-by f coll)

#### partition
(partition n coll)(partition n step coll)(partition n step pad coll)

#### partitionAll
(partition-all n)(partition-all n coll)(partition-all n step coll)

#### partitionBy
(partition-by f)(partition-by f coll)

#### frequencies
(frequencies coll)

#### union
(union)(union s1)(union s1 s2)(union s1 s2 & sets)

#### difference
(difference s1)(difference s1 s2)(difference s1 s2 & sets)

#### intersection
`(intersection s1)(intersection s1 s2)(intersection s1 s2 & sets)`
```js path=dist/core.js
var intersection = (...args) =>{
  let [arr1, arr2] = args;
  if(args.length === 1) return (arr) => intersection(arr1, arr);
  return arr1.filter((x) => arr2.includes(x));
}
```
usage: 
```js path=dist/test.core.js
assert.equal(intersection([1,2], [2,3]), 2)
```


#### every

#### whenFirst
(when-first bindings & body)
